<!-- snippets/component__slider.liquid -->
{% comment %}
  This is a standard slider component used for displaying a series of items in a scrollable horizontal layout. It is highly customizable with several options for tailoring its appearance and behavior.

  Accepts:
  - container_class: {string} This is a string that sets the classes for the slider container. It allows for custom styling of the slider container.
  - parent_class: {string} This is a string that sets the classes for the parent container. It allows for custom styling of the parent container.
  - slides: {Object} Object that contains all the slide items. Each item represents a single slide in the slider.
  - auto_scroll_delay: {integer} This sets the delay between each slide in the slider. It determines how long each slide should be displayed before transitioning to the next one. Leave blank to disable autoplay.
  - enable_arrows: {boolean} This indicates whether default arrows should be shown.
  - enable_arrows_over: {boolean} This indicates whether alternative arrows should be shown.
  - enable_arrows_over_single: {boolean} This indicates whether only one arrow should be shown.
  - enable_indicators: {boolean} This indicates whether slider indicators are shown.
  - enable_scrollbar: {boolean} This indicates whether the scrollbar should be shown.
  - enable_scroll_margin: {boolean} This indicates whether the scroll margin should be shown.
  - layout_arrow_alignment: {string} This sets the alignment of the arrows. Can be set to 'justify-start', 'justify-center', or 'justify-end'.
  - enable_default_gap: {boolean} This indicates whether the default gap should be enabled.

  Usage:
    {% capture slides %}
      {% for block in section.blocks %}
        ...
      {% endfor %}
    {% endcapture %}
    {% render 'component__slider',
      container_class: 'px-4',
      parent_class: '',
      slides: slides,
      auto_scroll_delay: 1000,
      enable_arrows: false,
      enable_arrows_over: false,
      enable_arrows_over_single: false,
      enable_indicators: false,
      enable_scrollbar: true,
      enable_scroll_margin: false,
      layout_arrow_alignment: 'justify-end',
      enable_default_gap: true
    %}

  Recommendations:
  - Use this snippet when you need to display a series of items in a horizontal scrollable layout. It is especially useful for product or image galleries.
  - Customize the appearance of the slider by passing in custom classes through the 'container_class' parameter.
  - Enable alternative arrow styles for a different look and feel by setting 'enable_arrows_over' to true.
{% endcomment %}

<div
  class="
    relative flex w-full flex-wrap
    {{ parent_class }}
  "
  x-data="
    {
      // DOM elements
      slider: null,
      _sliderItems: null,

      // Core state
      index: 1,
      sliderSize: 0,
      showArrows: true,

      // Auto scroll state
      width: '0%',
      currentWidth: 0,
      incrementPlaying: true,
      incrementCount: {{ auto_scroll_delay }}000 / 100,
      animationFrameId: null,

      // Event tracking for cleanup
      eventHandlers: [],
      resizeObserver: null,

      // Initialize component
      init() {
        // Initialize core elements
        this.slider = $el.querySelector('.js-slider');
        if (!this.slider) return;
        // Cache DOM elements once
        this._sliderItems = this.slider.querySelectorAll('.js-slider-item');
        this.sliderSize = this._sliderItems.length;

        // Setup component features
        this.setupSlideClickHandlers();
        this.setupOverflowDetection();
        this.setupScrollHandler();
        this.setupResizeObserver();

        // Setup auto-scroll if enabled
        if (this.incrementCount > 0) {
          this.autoIncrement();
        }

        // Setup cleanup
        this.$cleanup = this.cleanup;
      },

      // Add click handlers to all slider items
      setupSlideClickHandlers() {
        if (this.sliderSize === 0) return;

        this._sliderItems.forEach((item, i) => {
          this.registerEventHandler(
            item,
            'click',
            (e) => {
              const currentIndex = i + 1;
              if (currentIndex !== this.index) {
                this.scrollToIndex(currentIndex);
                e.stopPropagation();
              }
            }
          );
        });
      },

      // Detect if content overflows container (to show arrows)
      setupOverflowDetection() {
        const checkOverflow = () => {
          if (!this.slider) return;
          this.showArrows = this.slider.scrollWidth > this.slider.clientWidth;
        };

        // Initial check after a brief delay to ensure rendering
        setTimeout(checkOverflow, 300);
      },

      // Setup scroll event handler with throttling
      setupScrollHandler() {
        if (!this.slider) return;

        let isScrolling = false;
        const scrollHandler = () => {
          if (!isScrolling) {
            requestAnimationFrame(() => {
              this.updateActiveIndex();
              isScrolling = false;
            });
            isScrolling = true;
          }
        };

        this.registerEventHandler(this.slider, 'scroll', scrollHandler);
      },

      // Setup resize observer to check for overflow on resize
      setupResizeObserver() {
        if (!window.ResizeObserver || !this.slider) return;

        const checkOverflow = () => {
          this.showArrows = this.slider.scrollWidth > this.slider.clientWidth;
        };

        this.resizeObserver = new ResizeObserver(checkOverflow);
        this.resizeObserver.observe(this.slider);
      },

      // Helper method to register event handlers for cleanup
      registerEventHandler(element, event, handler) {
        if (!element) return null;

        element.addEventListener(event, handler);
        this.eventHandlers.push({ element, event, handler });
        return handler;
      },

      // Cleanup event listeners when component is destroyed
      cleanup() {
        // Remove all tracked event handlers
        this.eventHandlers.forEach(({ element, event, handler }) => {
          if (element) element.removeEventListener(event, handler);
        });

        // Clear any running animations
        if (this.animationFrameId) {
          cancelAnimationFrame(this.animationFrameId);
          this.animationFrameId = null;
        }

        // Disconnect resize observer if it exists
        if (this.resizeObserver) {
          this.resizeObserver.disconnect();
          this.resizeObserver = null;
        }

        this.eventHandlers = [];
      },

      // Update active index based on current scroll position
      updateActiveIndex() {
        if (!this.slider || !this._sliderItems || this.sliderSize === 0) return;

        const sliderRect = this.slider.getBoundingClientRect();
        const sliderCenter = sliderRect.left + sliderRect.width / 2;

        // Find the most visible slide (closest to center)
        let closestSlide = null;
        let minDistance = Infinity;

        this._sliderItems.forEach((item, i) => {
          const itemRect = item.getBoundingClientRect();
          const itemCenter = itemRect.left + itemRect.width / 2;
          const distance = Math.abs(itemCenter - sliderCenter);

          if (distance < minDistance) {
            minDistance = distance;
            closestSlide = i + 1;
          }
        });

        if (closestSlide !== null && closestSlide !== this.index) {
          this.index = closestSlide;
        }
      },

      // Scroll to a specific item by index
      scrollToIndex(indexToScroll) {
        if (!this.slider || !this._sliderItems || this.sliderSize === 0) return;

        this.index = indexToScroll;
        const targetIndex = indexToScroll - 1;
        const currentSlide = this._sliderItems[targetIndex];

        if (!currentSlide) return;

        // Calculate position to center the target slide
        const sliderWidth = this.slider.offsetWidth;
        const currentSlidePosition = currentSlide.offsetLeft;
        const currentSlideWidth = currentSlide.offsetWidth;
        const centerPosition = currentSlidePosition + currentSlideWidth / 2 - sliderWidth / 2;

        // Use smooth scrolling
        this.slider.scrollTo({
          top: 0,
          left: centerPosition,
          behavior: 'smooth'
        });

        // Reset auto increment if enabled
        if (this.incrementCount > 0) {
          this.resetAutoIncrement();
        }
      },

      // Find and scroll to the next visible item
      scrollNext() {
        if (!this.slider || !this._sliderItems || this.sliderSize === 0) return;

        const sliderRect = this.slider.getBoundingClientRect();
        const sliderRight = sliderRect.right;

        // Default to first slide if none found
        let nextSlideIndex = 1;
        let found = false;

        // Find first slide not fully visible on the right
        for (let i = 0; i < this.sliderSize; i++) {
          // Get slide based on current index, wrapping around if needed
          const slideIdx = this.index + i;
          const actualIdx = slideIdx === 0 ? 1 : slideIdx;
          const slide = this._sliderItems[actualIdx - 1];

          if (!slide) continue;

          const slideRect = slide.getBoundingClientRect();

          // If slide is partially or fully off-screen to the right (with small buffer)
          if (slideRect.right > sliderRight + 10) {
            nextSlideIndex = actualIdx;
            found = true;
            break;
          }
        }

        // Scroll to the found slide
        this.scrollToIndex(nextSlideIndex);

        // Reset auto increment if enabled
        if (this.incrementCount > 0) {
          this.resetAutoIncrement();
        }
      },

      // Find and scroll to the previous visible item
      scrollBack() {
        if (!this.slider || !this._sliderItems || this.sliderSize === 0) return;

        const sliderRect = this.slider.getBoundingClientRect();
        const sliderLeft = sliderRect.left;

        // Default to last slide if none found
        let prevSlideIndex = this.sliderSize;
        let found = false;

        // Find first slide not fully visible on the left
        for (let i = 0; i < this.sliderSize; i++) {
          // Get slide based on current index moving backward, wrapping if needed
          const offset = i + 1;
          const slideIdx = ((this.index - offset) + this.sliderSize) % this.sliderSize;
          const actualIdx = slideIdx === 0 ? this.sliderSize : slideIdx;
          const slide = this._sliderItems[actualIdx - 1];

          if (!slide) continue;

          const slideRect = slide.getBoundingClientRect();

          // If slide is partially or fully off-screen to the left (with small buffer)
          if (slideRect.left < sliderLeft - 10) {
            prevSlideIndex = actualIdx;
            found = true;
            break;
          }
        }

        // Scroll to the found slide
        this.scrollToIndex(prevSlideIndex);

        // Reset auto increment if enabled
        if (this.incrementCount > 0) {
          this.resetAutoIncrement();
        }
      },

      // Auto move to next slide with progress indicator
      autoIncrement() {
        if (this.incrementCount <= 0) return;

        const totalDuration = this.incrementCount * 100; // Total duration in ms
        const startTime = performance.now();

        const updateProgress = (currentTime) => {
          if (!this.incrementPlaying) return;

          const elapsedTime = currentTime - startTime;
          const progress = Math.min(elapsedTime / totalDuration, 1);

          this.currentWidth = progress * 100;
          this.width = this.currentWidth + '%';

          if (progress >= 1) {
            this.scrollNext();
            this.resetAutoIncrement();
          } else {
            this.animationFrameId = requestAnimationFrame(updateProgress);
          }
        };

        this.animationFrameId = requestAnimationFrame(updateProgress);
      },

      // Reset and restart auto increment animation
      resetAutoIncrement() {
        if (this.animationFrameId) {
          cancelAnimationFrame(this.animationFrameId);
          this.animationFrameId = null;
        }

        this.currentWidth = 0;
        this.width = '0%';

        if (this.incrementPlaying && this.incrementCount > 0) {
          this.autoIncrement();
        }
      },

      // Pause auto increment animation
      pauseIncrement() {
        this.incrementPlaying = false;

        if (this.animationFrameId) {
          cancelAnimationFrame(this.animationFrameId);
          this.animationFrameId = null;
        }
      },

      // Resume auto increment animation
      resumeIncrement() {
        if (!this.incrementPlaying && this.incrementCount > 0) {
          this.incrementPlaying = true;
          this.autoIncrement();
        }
      }
    }
  "
  x-init="init()"
>
  <div
    class="
      window--max-full group relative flex w-full flex-col
      {% if enable_scroll_margin %}
        {{ settings.x_margin }}
      {% endif %}
    "
    :class="
      {
        'lg:window--max-fullmenuclamp' : menu_sidebar,
        {% if settings.cart_drawer_style == 'fixed' %}
          'lg:window--max-fullcartclamp' : cart_drawer
        {% endif %}
      }
    "
  >
    {% comment %} Slides {% endcomment %}
    <div
      class="
        js-slider inline-flex w-full overflow-x-auto overflow-y-hidden scroll-smooth whitespace-nowrap px-4
        md:snap-x md:snap-mandatory
        {% if enable_default_gap %}
          gap-4
        {% endif %}
        {{ container_class }}
        {% if enable_scrollbar %}
          showscrollbar pb-4
        {% else %}
          hidescrollbar
        {% endif %}
      "
      style="
        {% unless enable_default_gap %}
          gap: {{ settings.gap_size }}px;
        {% endunless %}
        padding-top: {{ settings.border_element_width }}px;
        padding-bottom: {{ settings.border_element_width }}px;
        scroll-padding: {{ settings.border_element_width }}px;
      "
      x-ref="slider"
    >
      {{ slides }}
    </div>

    {% comment %} Default arrows {% endcomment %}
    {% if enable_arrows %}
      <div
        class="
          animation-300 absolute left-0 right-0 top-full z-10 flex w-full gap-2 pt-4
          {{ layout_arrow_alignment }}
          {% if section.settings.enable_margin %}
            {{ settings.x_margin }}
          {% else %}
            window--full
          {% endif %}
        "
        x-show="showArrows"
        x-cloak
      >
        <div>
          <button
            class="btn btn--plain btn--smaller cursor-w-resize !p-2"
            style="cursor: w-resize;"
            title="{{ 'actions.previous' | t }}"
            type="button"
            {% if settings.enable_animations %}
              x-transition:enter="animation-300"
              x-transition:enter-start="opacity-0"
              x-transition:enter-end="opacity-100"
              x-transition:leave="animation-300"
              x-transition:leave-start="opacity-100"
              x-transition:leave-end="opacity-0"
            {% endif %}
            @click="scrollBack();"
          >
            {% render 'component__icon', icon: 'chevron-left', size: '16', class: '' %}
          </button>
        </div>
        {% if enable_indicators and slider_size > 0 %}
          <div
            class="color__bg-overlay-1 border__button--radius relative flex flex-wrap items-center justify-center gap-2 overflow-hidden px-4 py-2"
          >
            {% if auto_scroll_delay > 0 %}
              <button
                class="flex leading-none"
                title="{{ 'actions.pause' | t }}"
                type="button"
                x-show="incrementPlaying"
                @click="pauseIncrement();"
              >
                {% render 'component__icon', icon: 'pause', size: '16', class: '' %}
              </button>
              <button
                class="flex leading-none"
                title="{{ 'actions.pause' | t }}"
                type="button"
                x-show="!incrementPlaying"
                @click="resumeIncrement();"
              >
                {% render 'component__icon', icon: 'play', size: '16', class: '' %}
              </button>
            {% endif %}
            {% if slider_size > 10 %}
              <span class="type--smaller flex gap-1">
                <span
                  class="leading-none"
                  x-text="index+1"
                  >1</span
                >
                <span
                  class="leading-none"
                  >/</span
                >
                <span
                  class="leading-none"
                >
                  {{ slider_size | plus: 1 }}
                </span>
              </span>
            {% else %}
              {% for i in (0..slider_size) %}
                <button
                  class="animation-300--all focus-visible:border--focus--inset color__bg-text h-2 w-2 rounded-full opacity-25"
                  :class="
                    {
                      '!opacity-100 !w-6': index === {{ i }}
                    }
                  "
                  type="button"
                  aria-label="slider_button_{{ i }}"
                  @click="scrollToIndex({{ i }});"
                ></button>
              {% endfor %}
            {% endif %}

            {% if auto_scroll_delay > 0 %}
              <div
                class="pointer-events-none absolute bottom-0 left-0 right-0 top-0 z-10 w-full"
                x-init="autoIncrement()"
              >
                <div class="h-full">
                  <div
                    class="color__bg-text h-full opacity-10 transition-all duration-100"
                    :style="{ width: width }"
                  ></div>
                </div>
              </div>
            {% endif %}
          </div>
        {% endif %}
        <div>
          <button
            class="btn btn--plain btn--smaller cursor-e-resize !p-2"
            style="cursor: e-resize;"
            title="{{ 'actions.next' | t }}"
            type="button"
            {% if settings.enable_animations %}
              x-transition:enter="animation-300"
              x-transition:enter-start="opacity-0"
              x-transition:enter-end="opacity-100"
              x-transition:leave="animation-300"
              x-transition:leave-start="opacity-100"
              x-transition:leave-end="opacity-0"
            {% endif %}
            @click="scrollNext();"
          >
            {% render 'component__icon', icon: 'chevron-right', size: '16', class: '' %}
          </button>
        </div>
      </div>
    {% endif %}

    {% comment %} Alternative arrows {% endcomment %}
    {% if enable_arrows_over %}
      <div
        class="
          pointer-events-none absolute left-0 right-0 top-0 z-10 flex w-full items-center
          {% if section.settings.enable_margin %}
            {{ settings.x_margin }}
          {% else %}
            window--full
          {% endif %}
          {% if enable_arrows_over_single %}
            justify-end
          {% else %}
            justify-between
          {% endif %}
        "
      >
        {% unless enable_arrows_over_single %}
          <div
            class="animation-300 pointer-events-auto flex items-center justify-start p-2 opacity-0 focus-within:opacity-100 group-hover:opacity-100"
          >
            <button
              class="btn btn--plain btn--smaller cursor-w-resize !p-1"
              title="{{ 'actions.previous' | t }}"
              type="button"
              {% if settings.enable_animations %}
                x-transition:enter="animation-300"
                x-transition:enter-start="opacity-0"
                x-transition:enter-end="opacity-100"
                x-transition:leave="animation-300"
                x-transition:leave-start="opacity-100"
                x-transition:leave-end="opacity-0"
              {% endif %}
              x-show="showArrows"
              x-cloak
              @click="scrollBack();"
            >
              {% render 'component__icon', icon: 'chevron-left', size: '14', class: '' %}
            </button>
          </div>
        {% endunless %}
        <div
          class="animation-300 pointer-events-auto flex items-center justify-start p-2 opacity-0 focus-within:opacity-100 group-hover:opacity-100"
        >
          <button
            class="btn btn--plain btn--smaller cursor-w-resize !p-1"
            title="{{ 'actions.previous' | t }}"
            type="button"
            {% if settings.enable_animations %}
              x-transition:enter="animation-300"
              x-transition:enter-start="opacity-0"
              x-transition:enter-end="opacity-100"
              x-transition:leave="animation-300"
              x-transition:leave-start="opacity-100"
              x-transition:leave-end="opacity-0"
            {% endif %}
            x-show="showArrows"
            x-cloak
            @click="scrollNext();"
          >
            {% render 'component__icon', icon: 'chevron-right', size: '14', class: '' %}
          </button>
        </div>
      </div>
    {% endif %}
  </div>
</div>
